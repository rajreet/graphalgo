{%extends "layout.html" %}

{% block head %}
<script src="{{ url_for('static', filename='dfs/dfs.js')}}"></script>
{% endblock %}

{%block input%}
<h3>Add Edges</h3>
<hr>
<small>Add edges between graphs by choosing a start and end node. You can construct a graph upto 20 nodes.</small>
<br><br>
<form id="edgeform" action="#">
    <div class="from-group row">
        <div class="col-6">
            <label class=>Start Node:</label>
        </div>
        <div class="col-6">
            <input type="number" class="form-control" id="start" size="8">
        </div>
        <small id="starterror" style="color:red;" class="col-12"></small> 
    </div>
    <br>
    <div class="from-group row">
        <div class="col-6">
            <label class=>End Node:</label>
        </div>
        <div class="col-6">
            <input type="number" class="form-control" id="end" size="8"> 
        </div>
        <small id="enderror" style="color:red;" class="col-12"></small>
    </div>
    <div class="form-group row">
        <div class="direction-wrapper">
            <input type="radio" id="undirected" name="direction" checked>
            <label>Undirected</label>
        </div>
        <div class="direction-wrapper">
            <input type="radio" id="directed" name="direction">
            <label>Directed</label>
        </div>
    </div>

    <button class="mybtn" id="edgebtn">Add Edge</button>
</form>

<small id="edgeerror" style="color:red;"></small>
<h3>Edges:</h3>
<ul id="edgelist"></ul>



<button id="run" class="mybtn">Run Algorithm</button>
<button id="clear" class='mybtn'>Clear Graph</button>

{%endblock%}

{% block code %}
<p>Depth-first search (DFS) is a straightforward graph traversal technique. The
    algorithm begins at a starting node, and proceeds to all other nodes that are
    reachable from the starting node using the edges of the graph.</p>
<p>
    Depth-first search always follows a single path in the graph as long as it
    finds new nodes. After this, it returns to previous nodes and begins to explore
    other parts of the graph. The algorithm keeps track of visited nodes, so that it
    processes each node only once.</p>

<p> DFS does not require any additional data structures and is easy to implement. Hence, this is generally preferred over BFS.</p>
<br>
<h4>Implementation</h4>
<p>DFS can be implemented using a simple recursion. Time complexity is <span style="font-weight: bold;">O(V+E)</span>.</p>
<pre><code class="language-cpp">
    //adjancency list 
    vector &lt;int&gt; adj[N];

    //array to keep track of visited nodes
    bool visited[N];

    void dfs(int s) {
        if (visited[s]) return;
        visited[s] = true;
        // process node s
        for (auto u: adj[s]) {
            dfs(u);
        }
    }
</code></pre>
{% endblock %}